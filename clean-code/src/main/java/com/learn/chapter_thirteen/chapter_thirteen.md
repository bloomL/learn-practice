# 并发编程
   - 对象是过程的抽象。线程是调度的抽象
1. 为什么要并发
   - 是一种解耦策略。帮助把`做什么（目的）`和`何时（时机）`做分解开
   - 解耦目的与时机能明显改进应用程序的`吞吐量`和`结构`
2. 挑战
3. 并发防御原则
   - 单一权责原则
     - 并发相关代码由自己的开发、修改和调优生命周期
     - 开发相关代码有自己要对付的挑战，和非并发相关代码不同
     - 写得不好的并发代码可能的出错方式数量也已经足具挑战性
     - 建议：`分离`并发相关代码与其他代码
   - 推论：限制数据作用域
   `synchronized`关键字在代码中保护一块使用共享对象的`临界区`。限制临界区数据
     - 会忘记保护一个或多个临界区 -> 破坏了修改共享数据的代码
     - 得多花力气保证一切都受到有效防护（破坏了DRY原则）
     - 很难找到错误源，也很难判断错误源
     - 建议：`谨记数据封装`；严格`限制`对可能被共享的数据的`访问`
   - 推论：使用数据复本（复制对象）
   - 推论：线程应尽可能地独立
     - 建议：尝试将数据分解到可被独立线程操作的独立子集
4. 了解Java库
   - 使用类库提供的`线程安全群集`
   - 使用`executor`框架执行无关任务
   - 尽可能使用`非锁定`解决方案
   - 有几个类并不是线程安全的
5. 了解执行模型
   - 限定资源（并发环境中有着`固定`尺寸或`数量`的`资源`）
   - 互斥（每一时刻`仅`有`一个线程`能访问`共享数据`或`共享资源`）
   - 线程饥饿（一个或一组线程在`很长时间`内或永久`被禁止`）
   - 死锁（两个或多个线程`互相等待``执行结束`。每个线程都拥有其他线程需要的资源，得不到其他线程拥有的资源，就无法停止）
   - 活锁（执行次序一致的线程，每个都想要起步，但发现其他线程已经`在路上`。由于`竞步`的原因。线程会持续尝试起步，但在长时间内却无法如愿，甚至永远无法启动）
   - 生产者-消费者模型
     - 一个或多个生产者线程创建某些工作，并`置于`缓存或`队列中`。一个或多个消费者线程从`队列中获取并完成`这些工作。生产者与消费者之间的队列是一种`限定资源`
   - 读者-作者模型
     - 当存在一个`主要`为读者线程提供信息源，但只`偶尔`被作者线程`更新`的共享资源，吞吐量就会是个问题。
增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息，这是种辛苦的平衡工作
   - 宴席哲学家（学习基础算法）
6. 警惕同步方法之间的依赖
   - 建议：避免使用一个共享对象的多个方法
   - 基于客户端的锁定（客户端代码在调用第一个方法前锁定服务端，确保范围覆盖调用最后一个方法的代码）
   - 基于服务端的锁定（服务端创建锁定服务端的方法，调用所有方法，然后解锁）
   - 适配服务端（创建执行锁定的中间层）
7. 保持同步区域微小
8. 很难编写正确的关闭代码
   - 尽早考虑`关闭`问题，尽早令其工作正常
9. 测试线程代码